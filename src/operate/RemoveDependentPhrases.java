package operate;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.function.Consumer;

import common.Folder;
import common.IO;
import text.Database;

/**
 * <p>This class searches the population of known phrases that occur more than once in the text of A
 * Song of Ice and Fire and removes from an in-memory copy of that population all instances of such
 * phrases that are part of an instance of some larger phrase. These quotes to be removed are
 * "dependent"; those that remain are "independent".</p> <p>Instead of actually removing these
 * dependent phrases from the source from which they were obtained, new files are created containing
 * only the independent quotes.</p> <p>The files for independent quotes are organized according to
 * the number of words in their phrases.</p>
 */
public class RemoveDependentPhrases {

    /**
     * <p>The largest number of words in any repeated phrase in the corpus: {@value}</p>
     */
    public static final int INIT_LOW_SIZE = FindRepeatedPhrases.MAX_PHRASE_SIZE-1;

    /**
     * <p>An exclusive lower bound for how small the smaller of two phrase-sizes being used at once
     * for dependence-testing can be. No phrase can be of this size ({@value}).</p>
     */
    public static final int LOW_SIZE_EXCLUSIVE_LOWER_BOUND = 0;//INIT_LOW_SIZE-2;

    /**
     * <p>The directory from which this class reads quote data.</p>
     * @see Folder#REPEATS
     */
    public static final Folder READ_FROM = Folder.REPEATS;

    /**
     * <p>The directory to which this class writes quote data for independent phrases.</p>
     * @see Folder#INDEPENDENT_INSTANCES
     */
    public static final Folder WRITE_TO = Folder.INDEPENDENT_INSTANCES;

    public static void main(String[] args){
        rmDepPhrases(IO.DEFAULT_MSG);
    }

    /**
     * <p>Iterates over a set of pre-existing files generated by FindRepeatedPhrases, starting at
     * the largest phrase-size for which the file output by FindRepeatedPhrases is not empty. For
     * each phrase-size considered, the repeated-phrase data for that size and for that size plus 1
     * are loaded into memory from the pertinent pre- existing files created by FindRepeatedPhrases,
     * except that the data for the previous size is carried over from one loop to the next and
     * reused as the data for the plus-one size in the next loop. Prints to file all those quotes of
     * the smaller phrase size specified in the current loop that are independent of the larger
     * quotes in the current group of larger phrases. If a problem occurs while reading a file,
     * System.exit is called, ending the program.</p>
     * @param args command-line arguments (unused)
     */
    public static void rmDepPhrases(Consumer<String> msg) {

        Database smallerPhrases = null; //inter-loop storage

        for(int lowSize=INIT_LOW_SIZE; lowSize>LOW_SIZE_EXCLUSIVE_LOWER_BOUND; lowSize--){

            try{
                Database largerPhrases = (smallerPhrases != null)
                        ? smallerPhrases
                        : new Database(new File( READ_FROM.filename(lowSize+1) ));
                smallerPhrases = new Database(new File(READ_FROM.filename(lowSize)));

                smallerPhrases.phrasesIndependentOf(largerPhrases)
                        .printPhrasesWithLocations(WRITE_TO.filename(lowSize));
            } catch(FileNotFoundException e){
            	throw new RuntimeException(IO.ERROR_EXIT_MSG + READ_FROM.filename(lowSize) + " or " + READ_FROM.filename(lowSize+1) );
            }
        }
    }
}
