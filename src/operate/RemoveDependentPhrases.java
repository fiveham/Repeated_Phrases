package operate;

import common.IO;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.HashMap;
import java.util.Map;
import java.util.function.BiPredicate;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import text.Chapter;
import text.FileBox;
import text.Location;
import text.PhraseBox;
import text.Quote;

/**
 * <p>This class searches the population of known phrases that occur more than once in the text of A
 * Song of Ice and Fire and removes from an in-memory copy of that population all instances of such
 * phrases that are part of an instance of some larger phrase. These quotes to be removed are
 * "dependent"; those that remain are "independent".</p> <p>Instead of actually removing these
 * dependent phrases from the source from which they were obtained, new files are created containing
 * only the independent quotes.</p> <p>The files for independent quotes are organized according to
 * the number of words in their phrases.</p>
 */
public class RemoveDependentPhrases {
    
    /**
     * <p>The largest number of words in any repeated phrase in the corpus: {@value}</p>
     */
    public static final int INIT_LOW_SIZE = FindRepeatedPhrases.MAX_PHRASE_SIZE-1;
    
    /**
     * <p>An exclusive lower bound for how small the smaller of two phrase-sizes being used at once
     * for dependence-testing can be. No phrase can be of this size ({@value}).</p>
     */
    public static final int LOW_SIZE_EXCLUSIVE_LOWER_BOUND = 0;
    
    /**
     * <p>Iterates over a set of pre-existing files generated by FindRepeatedPhrases, starting at
     * the largest phrase-size for which the file output by FindRepeatedPhrases is not empty. For
     * each phrase-size considered, the repeated-phrase data for that size and for that size plus 1
     * are loaded into memory from the pertinent pre- existing files created by FindRepeatedPhrases,
     * except that the data for the previous size is carried over from one loop to the next and
     * reused as the data for the plus-one size in the next loop.</p>
     * <p>Prints to file all those quotes of the smaller phrase size specified in the current loop 
     * that are independent of the larger quotes in the current group of larger phrases. If a 
     * problem occurs while reading a file, System.exit is called, ending the program.</p>
     * @param op the Operation whose folders will be used
     * @param args command-line args (not used)
     * @param msg receives and handles messages output by arbitrary parts of this operation
     */
    public static Map<Integer,PhraseBox> rmDepPhrases(
            Operation op, 
            String[] args, 
            Consumer<String> msg){
        
        FileBox smallerPhrases = null; //inter-loop storage
        Map<Integer,PhraseBox> result = new HashMap<>();
        
        for(int lowSize = INIT_LOW_SIZE; lowSize > LOW_SIZE_EXCLUSIVE_LOWER_BOUND; lowSize--){
            try{
                FileBox largerPhrases = (smallerPhrases != null)
                        ? smallerPhrases
                        : new FileBox(new File(op.readFrom().filename(lowSize + 1)));
                smallerPhrases = new FileBox(new File(op.readFrom().filename(lowSize)));
                result.put(
                        lowSize, 
                        phrasesIndependentOf(smallerPhrases, largerPhrases)
                                .printPhrasesWithLocations(op.writeTo().filename(lowSize)));
            } catch(FileNotFoundException e){
            	throw new RuntimeException(
            			IO.ERROR_EXIT_MSG 
            			+ op.readFrom().filename(lowSize) 
            			+ " or " 
            			+ op.readFrom().filename(lowSize + 1));
            }
        }
        
        return result;
    }
    
    /**
     * <p>Returns a PhraseBox containing exactly those quotes represented in {@code this.textCorpus}
     * that are independent of all the quotes represented in {@code otherDatabase.textCorpus}.</p>
     * @param small a FileBox of smaller phrases
     * @param large a FileBox of larger phrases
     * @return a PhraseBox containing exactly those quotes represented in {@code this.textCorpus}
     * that are independent of all the quotes represented in {@code otherDatabase.textCorpus}.
     */
    private static PhraseBox phrasesIndependentOf(FileBox small, FileBox large){
        PhraseBox result = new PhraseBox();
        
        for(Chapter chapter : small.chapters()){
            if(large.contains(chapter.getName())){
                addSelectively(result, small, large, chapter);
            } else{
                addAll(result, small, chapter);
            }
        }
        
        return result;
    }
    
    private static void addAll(PhraseBox result, FileBox small, Chapter chapter){
        small.get(chapter).forEach(
                (quote) -> result.add(quote.text(), new Location(quote.index(), chapter)));
    }
    
    private static void addSelectively(
            PhraseBox result, 
            FileBox small, 
            FileBox large, 
            Chapter chapter){
        
        Map<Integer, String> fileForLargePhrases = 
                large.get(chapter).stream()
                        .collect(Collectors.toMap(Quote::index, Quote::text));
        
        small.get(chapter).stream()
                .parallel()
                .forEach((phraseHere) -> {
                    SB largerPhraseAtLowerIndex = largerPhraseAtIndex(
                            0, 
                            phraseHere, 
                            phraseHere.index() - 1, 
                            String::endsWith, 
                            fileForLargePhrases);
                    
                    SB largerPhraseAtSameIndex = largerPhraseAtIndex(
                            fileForLargePhrases.size(), 
                            phraseHere, 
                            phraseHere.index(), 
                            String::startsWith, 
                            fileForLargePhrases);
                    
                    if(!largerPhraseAtLowerIndex.hasLargerPhrase() 
                            && !largerPhraseAtSameIndex.hasLargerPhrase()){
                        
                        //only independent (non-subsumed) phrases are added to result
                        result.add(phraseHere.text(), new Location(phraseHere.index(), chapter));
                    } else if(largerPhraseAtLowerIndex.isFalse() 
                            && largerPhraseAtSameIndex.isFalse()){
                        
                        throw new IllegalStateException(
                                "The smaller phrase \"" 
                                + shortForm(phraseHere.text()) 
                                + "\" is contained at the proper location in zero or one of the " 
                                + "two larger phrases that could contain it: " 
                                + "Phrase at some index in file " + chapter + ": \"" 
                                + shortForm(largerPhraseAtLowerIndex.s()) 
                                + "\" --- " 
                                + "Phrase at some index in file " + chapter + ": \"" 
                                + shortForm(largerPhraseAtSameIndex.s()) 
                                + "\".");
                    }
                });
    }
    
    /**
     * <p>A pair of a String and a Boolean.</p>
     * @author fiveham
     *
     */
    private static class SB{
        private final String s;
        private final Boolean b;
        
        SB(String s, Boolean b){
            this.s = s;
            this.b = b;
        }
        
        String s(){
            return s;
        }
        
        /**
         * <p>Returns true if the Boolean value of this pair is false (requiring that it not be 
         * null), otherwise returns false.</p>
         * @return true if the Boolean value of this pair is false (requiring that it not be null), 
         * otherwise returns false
         */
        boolean isFalse(){
            return hasLargerPhrase() && !b;
        }
        
        /**
         * <p>Returns true if the Boolean value of this pair is not null, which encodes the fact 
         * that the larger phrase to which this pair's String pertains exists in the text of the 
         * ASOIAF books and occurs multiple times in the books.</p>
         * @return true if the Boolean value of this pair is not null, false otherwise
         */
        boolean hasLargerPhrase(){
            return b != null;
        }
    }
    
    /**
     * 
     * @param index a value tested for equality with {@code phraseHere}{@code .index()}
     * @param phraseHere a Quote whose index and text are used
     * @param key 
     * @param whichEnd a function specifying how to test {@code fileForLargePhrases}{@code .get(}
     * {@code key}{@code )} and {@code phraseHere}{@code .text()}. This should be either 
     * {@link String#startsWith(String)} or {@link String#endsWith(String)}.
     * @param fileForLargePhrases
     * @return 
     */
    private static SB largerPhraseAtIndex(
            int index, 
            Quote phraseHere, 
            int key, 
            BiPredicate<String,String> whichEnd, 
            Map<Integer, String> fileForLargePhrases){
        
        String s;
        if(phraseHere.index() == index && null != (s = fileForLargePhrases.get(key))){
            Boolean b = whichEnd.test(s, phraseHere.text());
            return new SB(s,b);
        } else{
            return new SB(null, null);
        }
    }
    
    public static final String ELLIPSIS = " ... ";
    public static final int SHORT_FORM_HALF_FOR_ELIDED_MIDDLE = 25;
    public static final int SHORT_FORM_LENGTH = 
            SHORT_FORM_HALF_FOR_ELIDED_MIDDLE * 2 + ELLIPSIS.length();
    
    /**
     * <p>Returns a shortened form of the specified String.</p>
     * @param phrase the phrase of which a shortened form will be returned
     * @return the first 25 characters of phrase + " ... " + the last 25 characters if the phrase
     * has 55 or more characters, otherwise the entire phrase.
     */
    private static String shortForm(String phrase){
        return phrase.length() < SHORT_FORM_LENGTH
                ? phrase 
                : phrase.substring(0, SHORT_FORM_HALF_FOR_ELIDED_MIDDLE) 
                    + ELLIPSIS 
                    + phrase.substring(phrase.length() - 1 - SHORT_FORM_HALF_FOR_ELIDED_MIDDLE);
    }
}
